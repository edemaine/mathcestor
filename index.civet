#!/usr/bin/env node
"civet coffeeComment coffeeEq coffeeInterpolation coffeeNot"

declare global
  var fetch: typeof import('undici').fetch

{load as loadCheerio, type Cheerio, type Element} from 'cheerio'
#Civet: remove async
async function fromURL(url: string)
  response := fetch url |> await
  unless response.ok
    throw new Error "Failed to fetch #{url}"
  response.text() |> await |> loadCheerio

type ID = string

interface Degree
  degree: string
  institution: string
  thesis: string
  year: string
  advisors: ID[]

interface Person
  id: ID
  name: string
  degrees: Degree[]
  advisors: ID[]  # union of all advisors in all degrees
  descendants: ID[]

function indent(s: string): string
  trailing .= ''
  s
  # remove trailing newlines
  .replace /\n*$/, (m) =>
    trailing = m
    ''
  # indent remaining lines
  .replace /^/gm, '  '
  # put trailing newlines back
  .replace /$/, trailing

class Fetcher
  cache = new Map<ID, Person>() #Civet: remove ()
  # Did we already fetch this id?
  has(id: ID): boolean
    @cache.has id
  # Get cached person for this id, if already fetched
  #Civet: method
  #get(id: ID): Person | undefined
  #  @cache.get id
  get = (this: Fetcher, id: ID) -> @cache.get id

  urlFor(id: ID): string
    "https://www.mathgenealogy.org/id.php?id=#{id}"

  # Recursively fetch specified id and all its recursive advisors [async]
  recurseAdvisors(id: ID)
    return @ if @has id
    person := await @fetch id
    for advisor of person.advisors
      await @recurseAdvisors advisor
    @

  # Fetch data for specified this id, cache and return it [async].
  # Originally based on
  # https://github.com/davidalber/geneagrapher/blob/main/geneagrapher/grabber.py
  fetch(id: ID): Promise<Person>
    return @cache.get(id)! if @has id
    $ := await fromURL @urlFor id

    function extractIds(part: Cheerio<Element>): ID[]
      for place of part
        href := $(place).attr 'href'
        continue unless href?
        href.split("=").at(-1)!

    # Degrees/theses/advisors are split into sibling groups by these headings
    degreeHeading := 'div[style="line-height: 30px; text-align: center; margin-bottom: 1ex"]'
    degrees :=
      for element of $(degreeHeading)
        degree := $(element)
        section := degree.nextUntil degreeHeading
        span := degree.children 'span'

        degree: span.contents().first().text().trim() # leading text
        institution: span.find('span').text().trim() # inner span
        year: span.contents().last().text().trim() # trailing text
        thesis: section.find('#thesisTitle').text().trim()
                # following thesis title
        advisors: extractIds section.find('p[style="text-align: center; line-height: 2.75ex"]:contains("Advisor") a')

    person: Person :=
      id: id
      name: $("h2").text().trim()
      degrees: degrees
      advisors: Array.from new Set degrees.flatMap .advisors
      descendants: extractIds $('table a')
    @cache.set id, person
    person

  # HTML rendering

  # Keep track of which people have already been rendered,
  # initialized by `html` method and used by other `html*` methods.
  rendered = new Set<ID>() #Civet: remove ()

  # Call this to render HTML in one of two styles:
  # * "person": just the person themselves
  # * "advisors": all their recursive ancestors too
  # You should have already called `fetch` or `recursiveAdvisors`
  # on the same id, so that all data is already available in the cache.
  html(id: ID, content: "advisors" | "person"): string
    @rendered = new Set
    id
    #Civet: omit surrounding parens in next line
    |> ((@ as any)["html#{content[0].toUpperCase()}#{content[1..]}"] as (id: ID) => string)
    |> @htmlStyle
    |> ($) => """
      <!-- Generated by https://github.com/edemaine/mathcestor -->
      <!-- #{@rendered.size} total people, #{Array.from($.matchAll(/"node"/g)).length} lines with repetitions -->
      #{$}
    """

  htmlPerson(id: ID): string
    person := @get id
    unless person?
      throw new Error "Couldn't find person with ID #{id}; did you call recurseAdvisors?"
    {name, degrees} := person
    base := """<a href="#{@urlFor id}">#{name}</a>"""
    data .= ''
    if @rendered.has id
      "<em>#{base} (above)</em>"
    else
      @rendered.add id
      for {degree, institution, year} of degrees
        data += '; ' if data
        data += degree if degree
        data += ', ' if degree and institution
        data += institution if institution
        data += ', ' if data and year
        data += year if year
      data = " (#{data})" if data
      base + data

  htmlAdvisors(id: ID): string
    rendered := @rendered.has id
    s .= """
      <div class="node">
        <div class="person">
          #{@htmlPerson id}
        </div>
      </div>

    """
    {advisors} := @get(id)!
    if advisors.length and not rendered
      #Civet: use the following instead
      #[...middle, last] := advisors
      middle := [...advisors]
      [last] := middle.splice -1
      if middle.length
        s += """<div class="middle">\n"""
        for advisor of middle
          s += indent @htmlAdvisors advisor
        s += """</div>\n"""
      s += """<div class="last">\n"""
      s += indent @htmlAdvisors last
      s += """</div>\n"""
    s

  htmlStyle(html: string): string
    """
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <style>
      :root {
        --border: 2px solid gray;
      }
      .middle, .last { margin-left: 1em; }
      .middle { border-left: var(--border); }
      .node { display: flex; }
      .node::before {
        border-bottom: var(--border);
        width: 0.5em;
        height: 0.6em;
        display: inline-block;
        content: "\\00a0";
      }
      .last > .node::before {
        border-left: var(--border);
      }
      .person { padding-left: 0.25em; }
    </style>
    #{html}
    """

#Civet: remove async
async function main()
  root := process.argv[2]
  unless root
    console.log """
      Usage: mathcestor ID >out.html
      where ID is the number at the end of a URL from https://www.mathgenealogy.org/
    """
    process.exit 1
  fetcher := new Fetcher()
  fetcher.recurseAdvisors root
  |> await
  |> .html root, 'advisors'
  |> console.log

* as url from 'node:url'
* as fs from 'node:fs'
main() if import.meta.url.startsWith('file:') and
          fs.realpathSync(process.argv[1]) ==
          fs.realpathSync url.fileURLToPath import.meta.url
