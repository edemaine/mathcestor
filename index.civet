#!/usr/bin/env node
"civet coffeeComment coffeeEq coffeeInterpolation coffeeNot"

declare global
  var fetch: typeof import('undici').fetch

{load as loadCheerio, type Cheerio, type Element} from 'cheerio'
#Civet: remove async
async function fromURL(url: string)
  response := fetch url |> await
  unless response.ok
    throw new Error "Failed to fetch #{url}"
  response.text() |> await |> loadCheerio

type ID = string

interface Person
  id: ID
  name: string
  degree: string
  institution: string
  thesis: string
  year: string
  advisors: ID[]
  descendants: ID[]

function indent(s: string): string
  trailing .= ''
  s
  # remove trailing newlines
  .replace /\n*$/, (m) =>
    trailing = m
    ''
  # indent remaining lines
  .replace /^/gm, '    '
  # put trailing newlines back
  .replace /$/, trailing

# Fetcher based on https://github.com/davidalber/geneagrapher/blob/main/geneagrapher/grabber.py

class Fetcher
  cache = new Map<ID, Person>() #Civet: remove ()
  has(id: ID): boolean
    @cache.has id
  #Civet: method
  #get(id: ID): Person | undefined
  #  @cache.get id
  get = (this: Fetcher, id: ID) -> @cache.get id
  urlFor(id: ID): string
    "https://www.mathgenealogy.org/id.php?id=#{id}"

  recurseAdvisors(id: ID)
    return @ if @has id
    person := await @fetch id
    for advisor of person.advisors
      await @recurseAdvisors advisor
    @

  fetch(id: ID): Promise<Person>
    return @cache.get(id)! if @has id
    $ := await fromURL @urlFor id
    degree := $('div[style="line-height: 30px; text-align: center; margin-bottom: 1ex"] > span')
    .first()

    function extractIds(part: Cheerio<Element>): ID[]
      for place of part
        href := $(place).attr 'href'
        continue unless href?
        href.split("=").at(-1)!

    person: Person :=
      id: id
      name: $("h2").text().trim()
      degree: degree.contents().first().text().trim()
      institution: degree.find('span').text().trim()
      thesis: $('#thesisTitle').text().trim()
      year: degree.contents().last().text().trim()
      advisors: extractIds $('p[style="text-align: center; line-height: 2.75ex"]:contains("Advisor") a')
      descendants: extractIds $('table a')
    @cache.set id, person
    person

  rendered = new Set<ID>() #Civet: remove ()
  html(id: ID, content: "advisors" | "person"): string
    @rendered = new Set
    id
    #Civet: omit surrounding parens in next line
    |> ((@ as any)["html#{content[0].toUpperCase()}#{content[1..]}"] as (id: ID) => string)
    |> @htmlStyle
    |> ($) => """
      <!-- Generated by https://github.com/edemaine/mathcestor -->
      <!-- #{@rendered.size} total people, #{Array.from($.matchAll(/"line"/g)).length} lines with repetitions -->
      #{$}
    """

  htmlPerson(id: ID): string
    person := @get id
    unless person?
      throw new Error "Couldn't find person with ID #{id}; did you call recurseAdvisors?"
    {name, degree, institution, year} := person
    base := """<a href="#{@urlFor id}">#{name}</a>"""
    data .= ''
    if @rendered.has id
      "<em>#{base} (above)</em>"
    else
      @rendered.add id
      data += degree if degree
      data += ' ' if degree and institution
      data += "at #{institution}" if institution
      data += ', ' if data and year
      data += year if year
      data = " (#{data})" if data
      base + data

  htmlAdvisors(id: ID): string
    rendered := @rendered.has id
    s .= """
      <div class="node">
        <div class="line">
          <div class="person">
            #{@htmlPerson id}
          </div>
        </div>

    """
    {advisors} := @get(id)!
    if advisors.length and not rendered
      #Civet: use the following instead
      #[...middle, last] := advisors
      middle := [...advisors]
      [last] := middle.splice -1
      if middle.length
        s += """  <div class="middle">\n"""
        for advisor of middle
          s += indent @htmlAdvisors advisor
        s += """  </div>\n"""
      s += """  <div class="last">\n"""
      s += indent @htmlAdvisors last
      s += """  </div>\n"""
    s += """</div>\n"""
    s
  htmlStyle(html: string): string
    """
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <style>
      :root {
        --border: 2px solid gray;
      }
      .middle, .last { margin-left: 1.3em; }
      .middle { border-left: var(--border); }
      .line { display: flex; }
      .line::before {
        border-bottom: var(--border);
        width: 0.75em;
        height: 0.6em;
        display: inline-block;
        content: "\\00a0";
      }
      .last > .node > .line::before {
        border-left: var(--border);
      }
      .person { padding-left: 0.25em; }
    </style>
    #{html}
    """

#Civet: remove async
async function main()
  root := process.argv[2]
  unless root
    console.log """
      Usage: mathcestor ID >out.html
      where ID is the number at the end of a URL from https://www.mathgenealogy.org/
    """
    process.exit 1
  fetcher := new Fetcher()
  fetcher.recurseAdvisors root
  |> await
  |> .html root, 'advisors'
  |> console.log

* as url from 'node:url'
* as fs from 'node:fs'
main() if import.meta.url.startsWith('file:') and
          fs.realpathSync(process.argv[1]) ==
          fs.realpathSync url.fileURLToPath import.meta.url
